/*Test cases generated by Claude Sonnet4*/

#include "EEPROM/EEPROM.h"
#include "PicoI2C.h"
#include "FreeRTOS.h"
#include "task.h"
#include <stdio.h>
#include <cstring>
#include <memory>
#include <pico/stdio.h>

extern "C" {
    uint32_t read_runtime_ctr(void) {
        return timer_hw->timerawl;
    }
}

// Test task function
void test_eeprom_task(void *params) {
    // First, we need to create the I2C bus that the EEPROM will use
    // Using I2C bus 0 at 100kHz (standard speed for EEPROM)
    auto i2cbus{std::make_shared<PicoI2C>(0, 400000)};

    // Create the EEPROM object with I2C address 0x50 (common EEPROM address)
    // Check your EEPROM datasheet for the correct address
    EEPROM eeprom(i2cbus);

    printf("=== EEPROM Test Suite Starting ===\n\n");

    // Test 1: Write and read CO2 value
    // This tests basic 16-bit integer storage
    printf("Test 1: CO2 Value Storage\n");
    printf("--------------------------\n");

    uint16_t test_co2_write = 450;  // A typical CO2 reading in ppm
    printf("Writing CO2 value: %d ppm\n", test_co2_write);

    if (eeprom.writeCO2Value(test_co2_write)) {
        printf("Write successful!\n");

        // Small delay to ensure write cycle completes
        vTaskDelay(pdMS_TO_TICKS(20));

        uint16_t test_co2_read = 0;
        if (eeprom.readCO2Value(test_co2_read)) {
            printf("Read successful! Value: %d ppm\n", test_co2_read);

            if (test_co2_read == test_co2_write) {
                printf("PASS: CO2 value matches!\n\n");
            } else {
                printf("FAIL: CO2 value mismatch! Expected %d, got %d\n\n",
                       test_co2_write, test_co2_read);
            }
        } else {
            printf("FAIL: Could not read CO2 value\n\n");
        }
    } else {
        printf("FAIL: Could not write CO2 value\n\n");
    }

    // Test 2: Write and read SSID
    // This tests string storage with length prefix
    printf("Test 2: SSID Storage\n");
    printf("--------------------\n");

    const char* test_ssid = "MyTestNetwork";
    printf("Writing SSID: \"%s\" (length: %d)\n", test_ssid, strlen(test_ssid));

    if (eeprom.writeSSID(test_ssid)) {
        printf("Write successful!\n");

        vTaskDelay(pdMS_TO_TICKS(20));

        char read_ssid[33];  // 32 characters max + null terminator
        if (eeprom.readSSID(read_ssid)) {
            printf("Read successful! Value: \"%s\"\n", read_ssid);

            if (strcmp(read_ssid, test_ssid) == 0) {
                printf("PASS: SSID matches!\n\n");
            } else {
                printf("FAIL: SSID mismatch! Expected \"%s\", got \"%s\"\n\n",
                       test_ssid, read_ssid);
            }
        } else {
            printf("FAIL: Could not read SSID\n\n");
        }
    } else {
        printf("FAIL: Could not write SSID\n\n");
    }

    // Test 3: Write and read password
    printf("Test 3: Password Storage\n");
    printf("------------------------\n");

    const char* test_pwd = "SecurePassword123";
    printf("Writing password: \"%s\" (length: %d)\n", test_pwd, strlen(test_pwd));

    if (eeprom.writePWD(test_pwd)) {
        printf("Write successful!\n");

        vTaskDelay(pdMS_TO_TICKS(20));

        char read_pwd[33];
        if (eeprom.readPWD(read_pwd)) {
            printf("Read successful! Value: \"%s\"\n", read_pwd);

            if (strcmp(read_pwd, test_pwd) == 0) {
                printf("PASS: Password matches!\n\n");
            } else {
                printf("FAIL: Password mismatch! Expected \"%s\", got \"%s\"\n\n",
                       test_pwd, read_pwd);
            }
        } else {
            printf("FAIL: Could not read password\n\n");
        }
    } else {
        printf("FAIL: Could not write password\n\n");
    }

    // Test 4: Overwrite with shorter string
    // This tests whether the length prefix works correctly when replacing
    // a longer string with a shorter one
    printf("Test 4: String Overwrite Test\n");
    printf("-----------------------------\n");

    const char* long_ssid = "VeryLongNetworkName";
    const char* short_ssid = "Short";

    printf("Writing long SSID: \"%s\"\n", long_ssid);
    eeprom.writeSSID(long_ssid);
    vTaskDelay(pdMS_TO_TICKS(20));

    printf("Writing short SSID: \"%s\"\n", short_ssid);
    eeprom.writeSSID(short_ssid);
    vTaskDelay(pdMS_TO_TICKS(20));

    char read_overwrite[33];
    if (eeprom.readSSID(read_overwrite)) {
        printf("Read value: \"%s\"\n", read_overwrite);

        if (strcmp(read_overwrite, short_ssid) == 0) {
            printf("PASS: Overwrite successful, no leftover data!\n\n");
        } else {
            printf("FAIL: Overwrite failed! Expected \"%s\", got \"%s\"\n\n",
                   short_ssid, read_overwrite);
        }
    } else {
        printf("FAIL: Could not read after overwrite\n\n");
    }

    // Test 5: Boundary value test for CO2
    // Testing with edge case values
    printf("Test 5: CO2 Boundary Values\n");
    printf("---------------------------\n");

    uint16_t boundary_values[] = {0, 1, 255, 256, 10000, 65535};
    int num_boundary_tests = sizeof(boundary_values) / sizeof(boundary_values[0]);
    bool all_boundary_passed = true;

    for (int i = 0; i < num_boundary_tests; i++) {
        uint16_t test_value = boundary_values[i];
        printf("Testing CO2 value: %d\n", test_value);

        if (eeprom.writeCO2Value(test_value)) {
            vTaskDelay(pdMS_TO_TICKS(20));

            uint16_t read_value;
            if (eeprom.readCO2Value(read_value)) {
                if (read_value == test_value) {
                    printf("Value %d passed\n", test_value);
                } else {
                    printf("Value %d failed: got %d\n", test_value, read_value);
                    all_boundary_passed = false;
                }
            } else {
                printf("Could not read value %d\n", test_value);
                all_boundary_passed = false;
            }
        } else {
            printf("Could not write value %d\n", test_value);
            all_boundary_passed = false;
        }
    }

    if (all_boundary_passed) {
        printf("PASS: All boundary values correct!\n\n");
    } else {
        printf("FAIL: Some boundary values incorrect\n\n");
    }

    // Test 6: Empty string test
    printf("Test 6: Empty String Test\n");
    printf("-------------------------\n");

    const char* empty_string = "";
    printf("Writing empty string\n");

    if (eeprom.writeSSID(empty_string)) {
        vTaskDelay(pdMS_TO_TICKS(20));

        char read_empty[33];
        if (eeprom.readSSID(read_empty)) {
            if (strlen(read_empty) == 0) {
                printf("PASS: Empty string handled correctly!\n\n");
            } else {
                printf("FAIL: Expected empty string, got \"%s\"\n\n", read_empty);
            }
        } else {
            printf("FAIL: Could not read empty string\n\n");
        }
    } else {
        printf("FAIL: Could not write empty string\n\n");
    }

    // Test 7: Persistence test
    // This verifies data survives across multiple reads
    printf("Test 7: Data Persistence Test\n");
    printf("-----------------------------\n");

    const char* persist_ssid = "PersistTest";
    uint16_t persist_co2 = 777;

    printf("Writing test data...\n");
    eeprom.writeSSID(persist_ssid);
    vTaskDelay(pdMS_TO_TICKS(20));
    eeprom.writeCO2Value(persist_co2);
    vTaskDelay(pdMS_TO_TICKS(20));

    bool persistence_pass = true;

    // Read multiple times to verify consistency
    for (int i = 0; i < 5; i++) {
        char ssid_check[33];
        uint16_t co2_check;

        if (eeprom.readSSID(ssid_check) && eeprom.readCO2Value(co2_check)) {
            if (strcmp(ssid_check, persist_ssid) != 0 || co2_check != persist_co2) {
                persistence_pass = false;
                printf("Read %d failed\n", i + 1);
                break;
            } else {
                printf("Read %d: Data consistent\n", i + 1);
            }
        } else {
            persistence_pass = false;
            printf("Read %d: Failed to read\n", i + 1);
            break;
        }

        vTaskDelay(pdMS_TO_TICKS(10));
    }

    if (persistence_pass) {
        printf("PASS: Data persists correctly!\n\n");
    } else {
        printf("FAIL: Data persistence issue\n\n");
    }

    printf("=== EEPROM Test Suite Complete ===\n");

    // Test task ends here, but in a real application you'd keep running
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

// Main function to start the test
int main() {
    stdio_init_all();  // Initialize standard I/O for printf

    // Give the system a moment to stabilize
    sleep_ms(1000);

    printf("\n\nStarting EEPROM Tests...\n\n");

    // Create the test task
    // Stack size of 2048 bytes should be sufficient for the test
    xTaskCreate(
        test_eeprom_task,
        "EEPROM_Test",
        2048,
        NULL,
        1,
        NULL
    );

    // Start the FreeRTOS scheduler
    vTaskStartScheduler();

    // Should never reach here
    while (1) {
        tight_loop_contents();
    }

    return 0;
}
